

### איך בונים Rate Limiter כמו מקצוענים (בלי לחנוק את השרת או את המשתמשים)

רייט לימיטר (Rate Limiter) הוא אחד הכלים הכי בסיסיים בארסנל של כל מפתח Backend רציני – אבל כמו כל כלי חזק, אפשר להשתמש בו נכון... ואפשר להפוך אותו למלכודת.

בואו נבנה את זה חכם:

---

#### הגישה הלא נכונה: לימיטר גלובלי (ואל תעשו את זה)

לפני שנראה איך עושים נכון – בואו נראה מה לא לעשות: להחיל Rate Limiter אחיד על כל הבקשות.
  
```js
const rateLimit = require('express-rate-limit');

const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 דקות
  max: 100, // הגבלה גלובלית לכל הבקשות
});

app.use(globalLimiter);
```


מה הבעיה פה?
- כל הבקשות מקבלות יחס זהה: קריאה ל-`/about-us` וקריאה ל-`/api/login` נחשבות אותו דבר.
- אין הבחנה בין נתיבים רגישים לנתיבים רגילים.
- תוקפים יכולים לנצל את זה כדי להציף נתיבים לא חשובים ולבזבז את מגבלת הבקשות של משתמשים אמיתיים.
- בסוף – המשתמשים הנורמליים חווים חסימות מיותרות.

במילים אחרות: **לימיטר גלובלי הוא מתכון לבאסה.**

#### הגישה הנכונה: להחמיר איפה שצריך, לשחרר איפה שאפשר

אגב, אם תשאירו Rate Limiter גלובלי אחיד – תדעו שהאקרים מתים על זה. מבחינתם זה אומר שאפשר להציף את השרת בעשרות קריאות מיותרות לעמודים לא חשובים, לבזבז לכם את מכסת הבקשות על שטויות, להעמיס על המשאבים – ולגרום לכם להוציא הרבה יותר כסף על תשתיות, גם בלי מתקפה אמיתית.

יותר מזה – ברגע שאין בידול בין נתיבים, תוקף יכול לנצל את זה כדי לבצע המון בקשות דווקא לעמודים הרגישים באמת: שחזורי סיסמאות, העלאת קבצים, יצירת חשבונות חדשים, שיתוף מידע. אלה המקומות שבהם כל בקשה לא מפוקחת עלולה להפוך לחור אבטחתי אמיתי.

בקיצור: אל תעשו להם חיים קלים.

##### נתיבים כלליים (רגישות נמוכה)
```js
const generalLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 דקות
  max: 500,
});
app.use('/api/public', generalLimiter);
```

##### נתיבים בעלי רגישות בינונית (פרופיל משתמש וכדומה)
```js
const mediumSensitivityLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
});
app.use('/api/user', mediumSensitivityLimiter);
```

##### נתיבים רגישים מאוד (אימותים, שחזור סיסמה)
```js
const highSensitivityLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'יותר מדי ניסיונות. נסה שוב מאוחר יותר.',
});
app.use('/api/auth', highSensitivityLimiter);
```

---

#### הרחבה: חסימת IP סוררים (בלי לדרוך על לקוחות טובים)
```js
const blockedIps = new Set();
const whiteListedIps = new Set(['127.0.0.1', '192.168.1.100']);

const strictLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  handler: (req, res) => {
    blockedIps.add(req.ip);
    res.status(429).json({ message: 'נחסמת זמנית בגלל עודף בקשות.' });
  },
  skip: (req) => whiteListedIps.has(req.ip),
});

app.use((req, res, next) => {
  if (blockedIps.has(req.ip)) {
    return res.status(403).json({ message: 'הגישה נחסמה.' });
  }
  next();
});

app.use(strictLimiter);
```

---

#### בונוס: דינמיות לפי רמות משתמשים

רוצה ללכת שלב קדימה? תתאם את מגבלות ה-Rate Limiting לפי סוג המשתמש: אנונימי, רשום, מנהל מערכת. ככה אתה גם שומר על אבטחה וגם משפר חוויית שימוש.

---

### לסיכום

לימיטר טוב הוא לא מחסום – הוא רמזור חכם. כזה שיודע מתי לעצור, מתי להאט, ומתי לתת זכות קדימה למשתמשים הטובים.

תכנון נכון של מגבלות לא רק מגן על המערכת – הוא יוצר שירות יציב, מהיר וחווייתי גם בעומסים.

**תבנה חכם, תגן בחוכמה, ותן לשרת שלך לרוץ חלק. 🚀**


